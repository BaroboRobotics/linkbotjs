<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"jsx_main.jsx.html":{"id":"jsx_main.jsx.html","title":"Source: jsx/main.jsx","body":" DocStrap Namespaces Linkbots Classes AsyncLinkbot Global asyncBaroboBridge Source: jsx/main.jsx &quot;use strict&quot;; var manager = require('./manager.jsx'); var uimanager = require('./manager-ui.jsx'); var config = require('./config.jsx'); /** * Linkbots API interface. * @namespace Linkbots */ window.Linkbots = (function(){ var mod = {}; var startOpen = false; /** * Adds a Robot to the robot manager. * @function addRobot * @memberOf Linkbots * @param id {string} The robot id to add. */ mod.addRobot = function(id) { manager.addRobot(id); }; /** * @function removeRobot * @memberOf Linkbots * @desc Removes a Robot from the robot manager. * @param id {string} The robot id to remove. */ mod.removeRobot = function(id) { manager.removeRobot(id); }; /** * Opens the robot manager side menu. * @function openSideMenu * @memberOf Linkbots */ mod.openSideMenu = function() { uimanager.uiEvents.trigger('show-menu'); }; /** * Closes the robot manager side menu. * @function closeSideMenu * @memberOf Linkbots */ mod.closeSideMenu = function() { uimanager.uiEvents.trigger('hide-menu'); }; /** * @typedef AquiredLinkbots * @type Object * @property {Array.&lt;AsyncLinkbot&gt;} robots An array of robots. * @property {number} registered The total number of registered robots. * @property {number} ready The total number of robots in the ready state. */ /** * Acquires available robots from the robot manager and marks them as acquired. * @function acquire * @memberOf Linkbots * @param count {int} The number of robots you wish to acquire. * @return {AquiredLinkbots} */ mod.acquire = function(count) { return manager.acquire(count); }; /** * Relinquishes the robot back to the robot manager. It's the opposite of acquire. * @function relinquish * @memberOf Linkbots * @param {AsyncLinkbot} bot The linkbot that you no longer are using and wish to make available. */ mod.relinquish = function(bot) { return manager.relinquish(bot); }; /** * Scans for linkbots. * @function scan * @memberOf Linkbots */ mod.scan = function() { return baroboBridge.scan(); }; /** * If True is passed in the robot manager menu starts open. * @function startOpen * @memberOf Linkbots * @param value {boolean}. */ mod.startOpen = function(value) { startOpen = value; }; /** * Sets the title in the top navigation. * @function setNavigationTitle * @memberOf Linkbots * @param title {string} The title to set. */ mod.setNavigationTitle = function(title) { manager.setNavigationTitle(title); }; /** * Adds a breadcrumb to the top navigation. * @function addNavigationItem * @memberOf Linkbots * @param navItemObject {object} An object containing a url and a title. */ mod.addNavigationItem = function(navItemObject) { manager.addNavigationItem(navItemObject); }; /** * Sets the breadcrumbs to the array of navigation items. Replacing the existing breadcrumbs. * @function setNavigationItems * @memberOf Linkbots * @param navItemArray {array} An array of navigation objects. A navigation object contains a url and title. */ mod.setNavigationItems = function(navItemArray) { manager.setNavigationItems(navItemArray); }; /** * Adds an array of breadcrumbs to the top navigation. * @function addNavigationItems * @memberOf Linkbots * @param navItemArray {array} An array of navigation objects. A navigation object contains a url and title. */ mod.addNavigationItems = function(navItemArray) { manager.addNavigationItems(navItemArray); }; mod.setPathways = function(pathways) { if (!Array.isArray(pathways)) { pathways = [pathways]; } if (!config.set('pathways', pathways)) { uimanager.uiEvents.trigger('add-error', 'Unable to write pathways to the configuration file'); } }; mod.getPathways = function() { var pathways = config.get('pathways'); if (typeof pathways === 'undefined') { return []; } return pathways; }; /** * TODO: document manager events. */ mod.managerEvents = manager.event; /** * TODO document ui events. * @type {*|uiEvents|l} */ mod.uiEvents = uimanager.uiEvents; if(window.attachEvent) { window.attachEvent('onload', function() { uimanager.addUI(); if (startOpen) { uimanager.uiEvents.trigger('show-menu'); } }); } else { if(window.onload) { var originalOnLoad = window.onload; window.onload = function() { originalOnLoad(); uimanager.addUI(); if (startOpen) { uimanager.uiEvents.trigger('show-menu'); } }; } else { window.onload = function() { uimanager.addUI(); if (startOpen) { uimanager.uiEvents.trigger('show-menu'); } } } } return mod; })(); × Search results Close "},"js_barobo-bridge.js.html":{"id":"js_barobo-bridge.js.html","title":"Source: js/barobo-bridge.js","body":" DocStrap Namespaces Linkbots Classes AsyncLinkbot Global asyncBaroboBridge Source: js/barobo-bridge.js /** * This class exists for testing outside of Barobo browser. */ var asyncBaroboBridge = (function(main) { &quot;use strict&quot;; if (main.asyncBaroboBridge &amp;&amp; main.asyncBaroboBridge !== null) { return main.asyncBaroboBridge; } else { var _i, _j, _len, _len1, obj, signals, methods, k; methods = ['listFirmwareFiles', 'connectRobot', 'disconnectRobot', 'getAccelerometer', 'getFormFactor', 'getJointAngles', 'getJointSpeeds', 'getJointStates', 'getLedColor', 'getVersions', 'resetEncoderRevs', 'setBuzzerFrequency', 'setJointSpeeds', 'setJointStates', 'setLedColor', 'move', 'moveContinuous', 'moveTo', 'drive', 'driveTo', 'motorPower', 'stop', 'enableButtonEvents', 'enableEncoderEvents', 'enableJointEvents', 'enableAccelerometerEvents', 'firmwareUpdate', 'sendRobotPing']; signals = ['requestComplete', 'dongleEvent', 'acquire', 'relinquish', 'buttonEvent', 'encoderEvent', 'jointEvent', 'accelerometerEvent', 'robotEvent', 'connectionTerminated']; obj = { mock: true }; /* var randomInt = function(min,max) { return Math.floor(Math.random()*(max-min+1)+min); }; var colorMap = {}; */ var emptyFunction = function() { }; for (_i = 0, _len = methods.length; _i &lt; _len; _i++) { k = methods[_i]; obj[k] = emptyFunction; } for (_j = 0, _len1 = signals.length; _j &lt; _len1; _j++) { k = signals[_j]; obj[k] = { connect: emptyFunction, disconnect: emptyFunction }; } obj.enumerationConstants = function() { return { Button: { A: 1, B: 2, POWER: 0}, ButtonState: { DOWN:1, UP: 0}, FormFactor: {I:0, L: 1, T: 2}, JointState: {FAIL: 3, HOLD: 1, MOVING: 2, STOP: 0} }; }; obj.listFirmwareFiles = function() { return [&quot;v4.4.6.eeprom&quot;, &quot;v4.4.6.hex&quot;]; }; obj.configuration = {}; /* obj.getLEDColor = function(id) { if (!colorMap[id]) { colorMap[id] = {red:randomInt(0,255), green:randomInt(0,255), blue:randomInt(0,255)}; } return colorMap[id]; }; obj.setLEDColor = function(id, r, g, b) { colorMap[id] = {red:r, green:g, blue:b}; }; */ return obj; } })(this); × Search results Close "},"jsx_linkbot.jsx.html":{"id":"jsx_linkbot.jsx.html","title":"Source: jsx/linkbot.jsx","body":" DocStrap Namespaces Linkbots Classes AsyncLinkbot Global asyncBaroboBridge Source: jsx/linkbot.jsx &quot;use strict&quot;; var eventlib = require('./event.jsx'); var manager = require('./manager.jsx'); var firmware = require('./firmware.jsx'); var Version = require('./version.jsx'); var enumConstants = asyncBaroboBridge.enumerationConstants(); var requestId = 0; var callbacks = {}; var buttonEventCallbacks = {}; var encoderEventCallbacks = {}; var accelerometerEventCallbacks = {}; var jointEventCallbacks = {}; function addCallback (func) { var token = requestId++; callbacks[token] = func; return token; } function addGenericCallback () { return addCallback(function (error) { if (error.code !== 0) { // TODO add error handling code here. window.console.warn('error occurred [' + error.category + '] :: ' + error.message); } }); } module.exports.addCallback = addCallback; module.exports.addGenericCallback = addGenericCallback; asyncBaroboBridge.requestComplete.connect( function (token, error, result) { if (callbacks[token]) { callbacks[token](error, result); delete callbacks[token]; } } ); // Dongle events of the same value may occur consecutively (i.e., two // dongleDowns in a row), so track the state and only perform actions on state // changes. var dongleEventFilter = (function () { var lastStatus = null; return function (status, data) { if (!lastStatus || lastStatus !== status) { lastStatus = status; manager.event.trigger(status, data); } }; })(); // This function might be better inside the AsyncLinkbot object? Unsure. function showRobotUpdateButton (explanation, bot) { bot.status = &quot;update&quot;; bot.event.trigger('changed'); window.console.log(explanation); } // True if the error object e represents a particular error, given the error's // category and code in string form. function errorEq(e, category, code) { return e.category === category &amp;&amp; e.code === enumConstants.ErrorCategories[category][code]; } asyncBaroboBridge.dongleEvent.connect( function (error, firmwareVersion) { if (error.code == 0) { var version = Version.fromTriplet(firmwareVersion); if (version.eq(firmware.latestVersion())) { window.console.log('Dongle firmware version ', firmwareVersion); dongleEventFilter('dongleUp'); } else { dongleEventFilter('dongleUpdate', &quot;The dongle's firmware must be updated.&quot;); } } else { if (errorEq(error, 'baromesh', 'STRANGE_DONGLE')) { dongleEventFilter('dongleUpdate', &quot;A dongle is plugged in, but we are unable &quot; + &quot;to communicate with it. &quot; + &quot;You may need to update its firmware.&quot;); } else if (errorEq(error, 'baromesh', 'INCOMPATIBLE_FIRMWARE')) { dongleEventFilter('dongleUpdate', &quot;The dongle's firmware must be updated.&quot;); } else { dongleEventFilter('dongleDown'); window.console.warn('error occurred [' + error.category + '] :: ' + error.message); } } } ); asyncBaroboBridge.robotEvent.connect( function(error, id, firmwareVersion) { console.log('robot event triggered with ID: ' + id + ' and version: ', firmwareVersion); var robot = manager.getRobot(id); if (robot) { if (error.code == 0) { var version = Version.fromTriplet(firmwareVersion); robot.version = version; if (version.eq(firmware.latestVersion())) { robot.connect(); } else { showRobotUpdateButton(id + &quot;'s firmware must be updated.&quot;, robot); } } else if (errorEq(error, 'baromesh', 'INCOMPATIBLE_FIRMWARE')) { showRobotUpdateButton(id + &quot;'s firmware must be updated.&quot;, robot); } else { window.console.warn('error occurred [' + error.category + '] :: ' + error.message); } } } ); asyncBaroboBridge.buttonEvent.connect( function(id, buttonNumber, eventType, timestamp) { // TODO implement this. if (buttonEventCallbacks.hasOwnProperty(id)) { var objs = buttonEventCallbacks[id]; for (var i = 0; i &lt; objs.length; i++) { var obj = objs[i]; if (obj.buttonId == buttonNumber &amp;&amp; eventType == 1) { obj.callback(obj.robot, obj.data, {button: buttonNumber, timestamp: timestamp}); } } } } ); asyncBaroboBridge.encoderEvent.connect( function(id, jointNumber, anglePosition, timestamp) { if (encoderEventCallbacks.hasOwnProperty(id)) { var objs = encoderEventCallbacks[id]; for (var i = 0; i &lt; objs.length; i++) { var obj = objs[i]; if (obj.wheelId == jointNumber) { var diff = anglePosition - obj.robot._wheelPositions[jointNumber-1]; obj.robot._wheelPositions[jointNumber-1] = anglePosition; obj.callback(obj.robot, obj.data, {triggerWheel: jointNumber, position: anglePosition, difference:diff, timestamp: timestamp}); } } } } ); asyncBaroboBridge.jointEvent.connect( function(id, jointNumber, eventType, timestamp) { var objs = jointEventCallbacks[id]; for (var i = 0; i &lt; objs.length; i++) { var obj = objs[i]; obj.callback(obj.robot, obj.data, {jointNumber: jointNumber, eventType: eventType, timestamp: timestamp}); } } ); asyncBaroboBridge.accelerometerEvent.connect( function(id, x, y, z, timestamp) { if (accelerometerEventCallbacks.hasOwnProperty(id)) { var objs = accelerometerEventCallbacks[id]; for (var i = 0; i &lt; objs.length; i++) { var obj = objs[i]; obj.callback(obj.robot, obj.data, {x: x, y: y, z: z, timestamp: timestamp}); } } } ); asyncBaroboBridge.acquire.connect( function() { var acquisition = manager.acquire(1); var id = acquisition.robots.length &gt; 0 ? acquisition.robots[0].id : &quot;&quot;; asyncBaroboBridge.fulfillAcquire(id); } ); asyncBaroboBridge.relinquish.connect( function(id) { manager.relinquish(manager.getRobot(id)); } ); function rgbToHex(value) { if (!value || value === null || value === &quot;undefined&quot;) { return &quot;00&quot;; } var val = Math.round(value); val = val.toString(16); if (val.length &lt; 2) { val = &quot;0&quot; + val; } return val; } function sign(value) { return (value &gt; 0) - (value &lt; 0); } function colorToHex(color) { var red = rgbToHex(color.red); var green = rgbToHex(color.green); var blue = rgbToHex(color.blue); return red + green + blue; } module.exports.startFirmwareUpdate = function() { firmware.startUpdater(); }; /** * Linkbot. * @class AsyncLinkbot * @param _id {string} The id of the linkbot. * @constructor * @property _wheelRadius {number} The wheel radius. * @property status {string} The status of the linkbot. * @property version {string} The firmware version. * @property id {string} The robot id. */ module.exports.AsyncLinkbot = function AsyncLinkbot(_id) { var bot = this; var statuses = {0:&quot;offline&quot;, 1:&quot;ready&quot;, 2:&quot;acquired&quot;, 3:&quot;update&quot;}; var status = 0; var id = _id; var wheelRadius = 1.75; var joinDirection = [0, 0, 0]; var driveToValue = null; var driveToCalled = false; var version = null; /** * Enumeration constants. * @type {{Button, ButtonState, FormFactor, JointState}} */ bot.enums = enumConstants; function driveToCallback(error) { driveToCalled = false; if (error.code !== 0) { // TODO add error handling code here. window.console.warn('error occurred [' + error.category + '] :: ' + error.message); } else { if (driveToValue !== null) { bot.driveTo(driveToValue[0], driveToValue[1], driveToValue[2]); driveToValue = null; } } } function checkVersions(error, data) { if (0 === error.code) { var version = Version.fromTriplet(data); var robot = manager.getRobot(id); robot.version = version; window.console.log('checking version: ' + version); if (version.eq(firmware.latestVersion())) { window.console.log('Using firmware version: ' + version + ' for bot: ' + id); } else { showRobotUpdateButton(id + &quot;'s firmware must be updated.&quot;, robot); } } else { window.console.warn('error occurred checking firmware version [' + error.category + '] :: ' + error.message); } } bot._wheelPositions = [0, 0, 0]; // Public bot.__defineGetter__(&quot;_wheelRadius&quot;, function(){ return wheelRadius; }); bot.__defineSetter__(&quot;_wheelRadius&quot;, function(value){ wheelRadius = value; bot.event.trigger('changed'); }); bot.__defineGetter__(&quot;status&quot;, function(){ return statuses[status]; }); bot.__defineSetter__(&quot;version&quot;, function(value) { version = value; }); bot.__defineGetter__(&quot;version&quot;, function() { return version; }); bot.__defineSetter__(&quot;status&quot;, function(val) { if (val === &quot;ready&quot;) { status = 1; } else if (val === &quot;offline&quot;) { status = 0; } else if (val === &quot;acquired&quot;) { status = 2; } else if (val === &quot;update&quot;) { status = 3; } bot.event.trigger('changed'); }); bot.__defineGetter__(&quot;id&quot;, function() { return id; }); // For Backwards compatibility. bot.__defineGetter__(&quot;_id&quot;, function() { return id; }); /** * Color value. * @typedef ColorType * @property {number} red Value between 0 to 255 representing the red color value. * @property {number} green Value between 0 to 255 representing the red color value. * @property {number} blue Value between 0 to 255 representing the red color value. */ /** * Color Callback. * * @callback robotColorCallback * @param {ColorType} color The color values. */ /** * Hex Color Callback. * @callback robotHexColorCallback * @param {string} hexColor A hex string representing the LED color value. */ /** * Returns the robot LED color in a callback. * @function getColor * @memberOf AsyncLinkbot * @param {robotColorCallback} callback The color callback. */ bot.getColor = function(callback) { asyncBaroboBridge.getLedColor(id, addCallback(function(error, data) { if (0 == error.code) { callback(data); } else { callback({red:96,green:96,blue:96}); } })); }; /** * Returns the robot LED color in a callback. * @function getHexColor * @memberOf AsyncLinkbot * @param {robotHexColorCallback} callback The color callback. */ bot.getHexColor = function(callback) { asyncBaroboBridge.getLedColor(id, addCallback(function(error, data) { if (0 == error.code) { callback(colorToHex(data)); } else { callback('606060'); } })); }; /** * Sets the robots LED value. * @function color * @memberOf AsyncLinkbot * @param r {number} The red value between 0 and 255. * @param g {number} The green value between 0 and 255. * @param b {number} The blue value between 0 and 255. */ bot.color = function(r, g, b) { if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.setLedColor(id, token, r, g, b); bot.event.trigger('changed'); } }; /** * Sets the motor angular speed. * @function angularSpeed * @memberOf AsyncLinkbot * @param s1 {number} The angular speed value for motor 1. * @param s2 {number} The angular speed value for motor 2. * @param s3 {number} The angular speed value for motor 3. */ bot.angularSpeed = function(s1, s2, s3) { if (s2 === null) { s2 = s1; } if (s3 === null) { s3 = s1; } if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.setJointSpeeds(id, token, 7, s1, s2, s3); } }; /** * TODO description here. * @function move * @memberOf AsyncLinkbot * @param r1 {number} * @param r2 {number} * @param r3 {number} */ bot.move = function(r1, r2, r3) { if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.move(id, token, 7, r1, r2, r3); } }; /** * TODO description here. * @function moveTo * @memberOf AsyncLinkbot * @param r1 {number} * @param r2 {number} * @param r3 {number} */ bot.moveTo = function(r1, r2, r3) { if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.moveTo(id, token, 7, r1, r2, r3); } }; /** * TODO description here. * @function moveToOneMotor * @memberOf AsyncLinkbot * @param joint {number} * @param position {number} */ bot.moveToOneMotor = function(joint, position) { if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); var mask = 0; if (joint === 0) { mask = 1; } else if (joint === 1) { mask = 2; } else if (joint === 2) { mask = 4; } asyncBaroboBridge.moveTo(id, token, mask, position, position, position); } }; /** * TODO description here. * @function drive * @memberOf AsyncLinkbot * @param r1 {number} * @param r2 {number} * @param r3 {number} */ bot.drive = function(r1, r2, r3) { if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.drive(id, token, 7, r1, r2, r3); } }; /** * TODO description here. * @function driveTo * @memberOf AsyncLinkbot * @param r1 {number} * @param r2 {number} * @param r3 {number} */ bot.driveTo = function(r1, r2, r3) { if (status != 0 &amp;&amp; status != 3) { if (driveToCalled) { driveToValue = [r1, r2, r3]; } else { driveToCalled = true; var token = addCallback(driveToCallback); asyncBaroboBridge.driveTo(id, token, 7, r1, r2, r3); } } }; /** * Moves an I-Linkbot in the forward direction. * @function moveForward * @memberOf AsyncLinkbot */ bot.moveForward = function() { joinDirection[0] = 1; joinDirection[2] = -1; if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.moveContinuous(id, token, 7, joinDirection[0], joinDirection[1], joinDirection[2]); } }; /** * Moves an I-Linkbot in the backwards direction. * @function moveBackward * @memberOf AsyncLinkbot */ bot.moveBackward = function() { joinDirection[0] = -1; joinDirection[2] = 1; if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.moveContinuous(id, token, 7, joinDirection[0], joinDirection[1], joinDirection[2]); } }; /** * Moves an I-Linkbot to the left. * @function moveBackward * @memberOf AsyncLinkbot */ bot.moveLeft = function() { joinDirection[0] = -1; joinDirection[2] = -1; if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.moveContinuous(id, token, 7, joinDirection[0], joinDirection[1], joinDirection[2]); } }; /** * Moves an I-Linkbot to the right. * @function moveBackward * @memberOf AsyncLinkbot */ bot.moveRight = function() { joinDirection[0] = 1; joinDirection[2] = 1; if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.moveContinuous(id, token, 7, joinDirection[0], joinDirection[1], joinDirection[2]); } }; /** * Moves a Joint continuously in a specific direction. * @function moveJointContinuous * @memberOf AsyncLinkbot * @param joint {number} The robot motor number to move. * @param direction {number} (1,0, or -1) Positive numbers move the robot motor in the positive direction, zero stops and -1 moves the motor in the negative direction. * @return {boolean} True if the input was valid and sent to the robot. */ bot.moveJointContinuous = function(joint, direction) { var token, mask = 0; if (joint &gt;= 0 &amp;&amp; joint &lt;= 2) { if (direction &gt; 0) { joinDirection[joint] = 1; } else if (direction &lt; 0) { joinDirection[joint] = -1; } else { joinDirection[joint] = 0; // Special call for stopping so it relaxes the motor. token = addGenericCallback(); asyncBaroboBridge.stop(id, token, (1 &lt;&lt; joint)); return true; } if (status != 0 &amp;&amp; status != 3) { token = addGenericCallback(); if (joint === 0) { mask = 1; } else if (joint === 1) { mask = 2; } else if (joint === 2) { mask = 4; } asyncBaroboBridge.moveContinuous(id, token, mask, joinDirection[0], joinDirection[1], joinDirection[2]); } return true; } return false; }; /** * TODO describe the callback. * @function wheelPositions * @memberOf AsyncLinkbot * @param callback */ bot.wheelPositions = function(callback) { if (status != 0 &amp;&amp; status != 3) { var token = addCallback(function(error, data) { if (error.code == 0) { callback(data); } else { callback({values:[0, 0, 0], timestamp:-1}); } }); asyncBaroboBridge.getJointAngles (id, token); } }; /** * TODO describe the joint speed callback * @function getJointSpeeds * @memberOf AsyncLinkbot * @param callback */ bot.getJointSpeeds = function(callback) { if (status != 0 &amp;&amp; status != 3) { var token = addCallback(function(error, data) { if (error.code == 0) { callback(data); } else { window.console.warn('error occurred [' + error.category + '] :: ' + error.message); } }); asyncBaroboBridge.getJointSpeeds(id, token); } }; /** * Stops all motors on the robot. * @function stop * @memberOf AsyncLinkbot */ bot.stop = function() { joinDirection[0] = 0; joinDirection[2] = 0; if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.stop(id, token); } }; /** * Sets the buzzer frequency for the robot. This is how you make it make sounds. * @function buzzerFrequency * @memberOf AsyncLinkbot * @param freq {number} The frequency value. */ bot.buzzerFrequency = function(freq) { if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.setBuzzerFrequency(id, token, freq); } }; /** * Moves all the Linkbot motors to the zero position. * @function zero * @memberOf AsyncLinkbot */ bot.zero = function() { if (asyncBaroboBridge.resetEncoderRevs) { var token = addCallback(function(error) { if (error.code !== 0) { // TODO add error handling code here. window.console.warn('error occurred [' + error.category + '] :: ' + error.message); } else { bot.moveTo(0, 0, 0); } }); asyncBaroboBridge.resetEncoderRevs(id, token); } else { bot.moveTo(0, 0, 0); } }; /** * Returns the Linkbot form factor. TODO describe the callback. * @param callback */ bot.getFormFactor = function(callback) { if (status != 0 &amp;&amp; status != 3 &amp;&amp; callback) { var token = addCallback(function(error, data) { if (error.code == 0) { callback(data); } else { window.console.warn('error occurred [' + error.category + '] :: ' + error.message); } }); asyncBaroboBridge.getFormFactor(id, token); } }; /** * Disconnects from the Linkbot. It also calls the stop() and unregister methods before disconnecting. * @function disconnect * @memberOf AsyncLinkbot * @return {string} The Linkbot id. */ bot.disconnect = function() { bot.stop(); bot.unregister(); var token = addGenericCallback(); asyncBaroboBridge.disconnectRobot(id, token); bot.status = &quot;offline&quot;; return id; }; /** * TODO describe the connect callback. * @function connect * @memberOf AsyncLinkbot * @param callback */ bot.connect = function(callback) { var token; if (status == 0) { asyncBaroboBridge.connectRobot(id, addCallback(function(error) { if (0 == error.code) { // If a TCP tunnel is currently active for this robot, it starts // acquired. bot.status = asyncBaroboBridge.isTunnelActive(id) ? &quot;acquired&quot; : &quot;ready&quot;; bot.event.trigger('changed'); asyncBaroboBridge.getVersions(id, addCallback(checkVersions)); } else if (errorEq(error, 'rpc', 'DECODING_FAILURE') || errorEq(error, 'rpc', 'PROTOCOL_ERROR') || errorEq(error, 'rpc', 'INTERFACE_ERROR')) { showRobotUpdateButton(&quot;We are unable to communicate with &quot; + id + &quot;. It may need a firmware update.&quot;, bot); } else if (errorEq(error, 'rpc', 'VERSION_MISMATCH')) { showRobotUpdateButton(id + &quot;'s firmware must be updated.&quot;, bot); } else { window.console.warn('error occurred [' + error.category + '] :: ' + error.message); } if (callback) { callback(error); } })); } else { token = addCallback(function(error) { if (0 != error.code) { status = 0; bot.event.trigger('changed'); } else { window.console.warn('error occurred [' + error.category + '] :: ' + error.message); } if (callback) { callback(error); } }); asyncBaroboBridge.getLedColor(id, token); } }; /** * Registers for Linkbot events. * @function register * @memberOf AsyncLinkbot * @deprecated * @param connections */ bot.register = function(connections) { var obj, token; if (status == 0 || status == 3 || typeof(connections) == 'undefined') { return; } if (connections.hasOwnProperty('button')) { buttonEventCallbacks.hasOwnProperty(id) || (buttonEventCallbacks[id] = []); for (var buttonId in connections.button) { if (connections.button.hasOwnProperty(buttonId)) { obj = connections.button[buttonId]; buttonEventCallbacks[id].push({ robot: bot, buttonId: buttonId, callback: obj.callback, data: obj.data }); } } if (buttonEventCallbacks[id].length &gt; 0) { token = addGenericCallback(); asyncBaroboBridge.enableButtonEvents (id, token, true); } } if (connections.hasOwnProperty('wheel')) { var granularity = 5.0; encoderEventCallbacks.hasOwnProperty(id) || (encoderEventCallbacks[id] = []); for (var wheelId in connections.wheel) { if (connections.wheel.hasOwnProperty(wheelId)) { obj = connections.wheel[wheelId]; encoderEventCallbacks[id].push({ robot: bot, wheelId: wheelId, callback: obj.callback, data: obj.data }); if (obj.hasOwnProperty('distance') &amp;&amp; obj.distance &lt; granularity) { granularity = obj.distance; } } } if (encoderEventCallbacks[id].length &gt; 0) { token = addGenericCallback(); asyncBaroboBridge.enableEncoderEvents(id, token, granularity, true); } } if (connections.hasOwnProperty('joint')) { obj = connections.joint; jointEventCallbacks.hasOwnProperty(id) || (jointEventCallbacks[id] = []); jointEventCallbacks[id].push({robot:bot, callback:obj.callback, data:obj.data}); token = addGenericCallback(); asyncBaroboBridge.enableJointEvents(id, token, true); } if (connections.hasOwnProperty('accel')) { obj = connections.accel; accelerometerEventCallbacks.hasOwnProperty(id) || (accelerometerEventCallbacks[id] = []); accelerometerEventCallbacks[id].push({robot:bot, callback:obj.callback, data:obj.data}); token = addGenericCallback(); asyncBaroboBridge.enableAccelerometerEvents(id, token, true); } }; /** * Unregisters from Linkbot events. * @function unregister * @memberOf AsyncLinkbot * @deprecated */ bot.unregister = function() { var token; if (buttonEventCallbacks.hasOwnProperty(id) &amp;&amp; buttonEventCallbacks[id].length &gt; 0) { token = addGenericCallback(); asyncBaroboBridge.enableButtonEvents (id, token, false); } if (encoderEventCallbacks.hasOwnProperty(id) &amp;&amp; encoderEventCallbacks[id].length &gt; 0) { token = addGenericCallback(); asyncBaroboBridge.enableEncoderEvents(id, token, 5.0, false); } if (accelerometerEventCallbacks.hasOwnProperty(id) &amp;&amp; accelerometerEventCallbacks[id].length &gt; 0) { token = addGenericCallback(); asyncBaroboBridge.enableAccelerometerEvents(id, token, false); } if (jointEventCallbacks.hasOwnProperty(id) &amp;&amp; jointEventCallbacks[id].length &gt; 0) { token = addGenericCallback(); asyncBaroboBridge.enableJointEvents(id, token, false); } }; bot.event = eventlib.Events.extend({}); /** * Deprecated Button Constants. * Used when registering button callbacks. */ bot.BUTTON_POWER = bot.enums.Button.POWER; bot.BUTTON_A = bot.enums.Button.A; bot.BUTTON_B = bot.enums.Button.B; }; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Namespaces Linkbots Classes AsyncLinkbot Global asyncBaroboBridge Global Members asyncBaroboBridge This class exists for testing outside of Barobo browser. Source: js/barobo-bridge.js, line 4 Type Definitions AquiredLinkbots Type: Object Properties: Name Type Description robots Array.&lt;AsyncLinkbot&gt; An array of robots. registered number The total number of registered robots. ready number The total number of robots in the ready state. Source: jsx/main.jsx, line 50 ColorType Color value. Properties: Name Type Description red number Value between 0 to 255 representing the red color value. green number Value between 0 to 255 representing the red color value. blue number Value between 0 to 255 representing the red color value. Source: jsx/linkbot.jsx, line 306 robotColorCallback(color) Color Callback. Parameters: Name Type Description color ColorType The color values. Source: jsx/linkbot.jsx, line 314 robotHexColorCallback(hexColor) Hex Color Callback. Parameters: Name Type Description hexColor string A hex string representing the LED color value. Source: jsx/linkbot.jsx, line 321 × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Namespaces Linkbots Classes AsyncLinkbot Global asyncBaroboBridge Classes Classes AsyncLinkbot Namespaces Linkbots × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" DocStrap Namespaces Linkbots Classes AsyncLinkbot Global asyncBaroboBridge Namespaces Classes AsyncLinkbot Namespaces Linkbots × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Namespaces Linkbots Classes AsyncLinkbot Global asyncBaroboBridge LinkbotJS APIThis is the user documentation for LinkbotJS. It describes version 0.0.3,which is available here: linkbot.js.zip v0.0.3 Source code and contributor documentation is available on Github atBaroboRobotics/LinkbotJS. This API has two methods for managing robots and aLinkbot classfor controlling individual robots. The two management methods arescan andconnect. Linkbots Object Methodsscan returns a list of ids. var availIds = Linkbots.scan();connect is straightforward, though it might throw an error if theconnection fails. As mentioned above, it returns a Linkbot object. var bot; try { bot = Linkbots.connect(id); } catch(/* TODO */) { } Linkbot ClassTo get started, obtain a Linkbot object withconnect: var bot = Linkbots.connect(id);Linkbot objects have the following methods:color,angularSpeed,move,moveTo,stop,wheelPositions,disconnect,register, andunregister. Controlling the Linkbotcolor sets the robot's LED. Inputs are r, g, b, with values0-255. bot.color(255, 0, 0); // Set LED to red.angularSpeedsets wheel speeds, in degrees per second. This is treated as a magnitude.Only use positive values. Argument 1 corresponds to wheel 1, etc. bot.angularSpeed(10, 20, 10); /* bad: negative numbers */ /* bot.angularSpeed(-10, 10, 20) */If you only pass one argument, LinkbotJS will use that speed for all thewheels. /* same as bot.angularSpeed(10,10,10) */ bot.angularSpeed(10);moveruns the wheels the specified number of degrees. The speed they move at iscontrolled by angularSpeed. Positive values movethe wheel clockwise. bot.move(10, 0, -10);moveTomoves the wheels to a particular absolute position. The Linkbot has aninternal sense of zero that it uses for this method. stopis an emergency stop! bot.stop();wheelPositionsreturns an array of absolute wheel positions. disconnectrelinquishes control of the robot. It also invalidates the object it isexecuted on. Let me know if that's weird. bot.disconnect();Linkbot EventsLinkbots can communicate with your code through event callbacks. Callbacks canberegisteredandunregistered, and will be invoked in a standardway: /* Callback invocation */ callback(robot, userData, event)TODO: explain the parameters once the design settles down. The available event types are listed below. registerIn lieu of complete documentation, here is an example of registering threecallbacks: bot.register({ wheel: { /* When wheel 1 moves 20 degrees, run doStuff. Pass myData as 2nd argument to doStuff. */ 1: { distance: 20, callback: doStuff, data: myData }, /* Run doOtherThings whenever wheel 2 moves at all. */ 2: { callback: doOtherThings } }, button: { /* Run fireZeMissiles when button 3 is pressed. */ 3: { callback: fireZeMissiles } } }) unregisterfixme: unimplemented Event typesThe available events are: buttonThe event object (the third argument to the callback) has form { buttonId(int) }wheelThe event object has form { triggerWheel(int), / which wheel triggered the event? / timestamp(int), / when did the Linkbot fire the event? / positions([int]) / wheel positions when the event fired / } Including the API in your codeEventual support of require.js is planned, but for now, include linkbot.jsbefore your application code, and Linkbots will be available at theglobal scope. × Search results Close "},"AsyncLinkbot.html":{"id":"AsyncLinkbot.html","title":"Class: AsyncLinkbot","body":" DocStrap Namespaces Linkbots Classes AsyncLinkbot Global asyncBaroboBridge Class: AsyncLinkbot AsyncLinkbot AsyncLinkbot new AsyncLinkbot(_id) Linkbot. Parameters: Name Type Description _id string The id of the linkbot. Properties: Name Type Description _wheelRadius number The wheel radius. status string The status of the linkbot. version string The firmware version. id string The robot id. Source: jsx/linkbot.jsx, line 223 Methods &lt;static&gt; angularSpeed(s1, s2, s3) Sets the motor angular speed. Parameters: Name Type Description s1 number The angular speed value for motor 1. s2 number The angular speed value for motor 2. s3 number The angular speed value for motor 3. Source: jsx/linkbot.jsx, line 373 &lt;static&gt; buzzerFrequency(freq) Sets the buzzer frequency for the robot. This is how you make it make sounds. Parameters: Name Type Description freq number The frequency value. Source: jsx/linkbot.jsx, line 627 &lt;static&gt; color(r, g, b) Sets the robots LED value. Parameters: Name Type Description r number The red value between 0 and 255. g number The green value between 0 and 255. b number The blue value between 0 and 255. Source: jsx/linkbot.jsx, line 358 &lt;static&gt; connect(callback) TODO describe the connect callback. Parameters: Name Type Description callback Source: jsx/linkbot.jsx, line 696 &lt;static&gt; disconnect() Disconnects from the Linkbot. It also calls the stop() and unregister methods before disconnecting. Source: jsx/linkbot.jsx, line 679 Returns: The Linkbot id. Type string &lt;static&gt; drive(r1, r2, r3) TODO description here. Parameters: Name Type Description r1 number r2 number r3 number Source: jsx/linkbot.jsx, line 446 &lt;static&gt; driveTo(r1, r2, r3) TODO description here. Parameters: Name Type Description r1 number r2 number r3 number Source: jsx/linkbot.jsx, line 461 &lt;static&gt; getColor(callback) Returns the robot LED color in a callback. Parameters: Name Type Description callback robotColorCallback The color callback. Source: jsx/linkbot.jsx, line 327 &lt;static&gt; getHexColor(callback) Returns the robot LED color in a callback. Parameters: Name Type Description callback robotHexColorCallback The color callback. Source: jsx/linkbot.jsx, line 342 &lt;static&gt; getJointSpeeds(callback) TODO describe the joint speed callback Parameters: Name Type Description callback Source: jsx/linkbot.jsx, line 594 &lt;static&gt; move(r1, r2, r3) TODO description here. Parameters: Name Type Description r1 number r2 number r3 number Source: jsx/linkbot.jsx, line 394 &lt;static&gt; moveBackward() Moves an I-Linkbot to the right. Source: jsx/linkbot.jsx, line 523 &lt;static&gt; moveBackward() Moves an I-Linkbot in the backwards direction. Source: jsx/linkbot.jsx, line 495 &lt;static&gt; moveBackward() Moves an I-Linkbot to the left. Source: jsx/linkbot.jsx, line 509 &lt;static&gt; moveForward() Moves an I-Linkbot in the forward direction. Source: jsx/linkbot.jsx, line 481 &lt;static&gt; moveJointContinuous(joint, direction) Moves a Joint continuously in a specific direction. Parameters: Name Type Description joint number The robot motor number to move. direction number (1,0, or -1) Positive numbers move the robot motor in the positive direction, zero stops and -1 moves the motor in the negative direction. Source: jsx/linkbot.jsx, line 537 Returns: True if the input was valid and sent to the robot. Type boolean &lt;static&gt; moveTo(r1, r2, r3) TODO description here. Parameters: Name Type Description r1 number r2 number r3 number Source: jsx/linkbot.jsx, line 409 &lt;static&gt; moveToOneMotor(joint, position) TODO description here. Parameters: Name Type Description joint number position number Source: jsx/linkbot.jsx, line 424 &lt;static&gt; register(connections) Registers for Linkbot events. Parameters: Name Type Description connections Deprecated: Yes Source: jsx/linkbot.jsx, line 745 &lt;static&gt; stop() Stops all motors on the robot. Source: jsx/linkbot.jsx, line 613 &lt;static&gt; unregister() Unregisters from Linkbot events. Deprecated: Yes Source: jsx/linkbot.jsx, line 812 &lt;static&gt; wheelPositions(callback) TODO describe the callback. Parameters: Name Type Description callback Source: jsx/linkbot.jsx, line 574 &lt;static&gt; zero() Moves all the Linkbot motors to the zero position. Source: jsx/linkbot.jsx, line 640 × Search results Close "},"Linkbots.html":{"id":"Linkbots.html","title":"Namespace: Linkbots","body":" DocStrap Namespaces Linkbots Classes AsyncLinkbot Global asyncBaroboBridge Namespace: Linkbots Linkbots Linkbots API interface. Source: jsx/main.jsx, line 6 Methods &lt;static&gt; acquire(count) Acquires available robots from the robot manager and marks them as acquired. Parameters: Name Type Description count int The number of robots you wish to acquire. Source: jsx/main.jsx, line 58 Returns: Type AquiredLinkbots &lt;static&gt; addNavigationItem(navItemObject) Adds a breadcrumb to the top navigation. Parameters: Name Type Description navItemObject object An object containing a url and a title. Source: jsx/main.jsx, line 103 &lt;static&gt; addNavigationItems(navItemArray) Adds an array of breadcrumbs to the top navigation. Parameters: Name Type Description navItemArray array An array of navigation objects. A navigation object contains a url and title. Source: jsx/main.jsx, line 121 &lt;static&gt; addRobot(id) Adds a Robot to the robot manager. Parameters: Name Type Description id string The robot id to add. Source: jsx/main.jsx, line 14 &lt;static&gt; closeSideMenu() Closes the robot manager side menu. Source: jsx/main.jsx, line 41 &lt;static&gt; openSideMenu() Opens the robot manager side menu. Source: jsx/main.jsx, line 33 &lt;static&gt; relinquish(bot) Relinquishes the robot back to the robot manager. It's the opposite of acquire. Parameters: Name Type Description bot AsyncLinkbot The linkbot that you no longer are using and wish to make available. Source: jsx/main.jsx, line 68 &lt;static&gt; removeRobot(id) Removes a Robot from the robot manager. Parameters: Name Type Description id string The robot id to remove. Source: jsx/main.jsx, line 24 &lt;static&gt; scan() Scans for linkbots. Source: jsx/main.jsx, line 77 &lt;static&gt; setNavigationItems(navItemArray) Sets the breadcrumbs to the array of navigation items. Replacing the existing breadcrumbs. Parameters: Name Type Description navItemArray array An array of navigation objects. A navigation object contains a url and title. Source: jsx/main.jsx, line 112 &lt;static&gt; setNavigationTitle(title) Sets the title in the top navigation. Parameters: Name Type Description title string The title to set. Source: jsx/main.jsx, line 94 &lt;static&gt; startOpen(value) If True is passed in the robot manager menu starts open. Parameters: Name Type Description value boolean . Source: jsx/main.jsx, line 85 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
