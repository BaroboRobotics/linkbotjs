<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"jsx_main.jsx.html":{"id":"jsx_main.jsx.html","title":"Source: jsx/main.jsx","body":" DocStrap Namespaces Linkbots Classes AsyncLinkbot Global asyncBaroboBridge Source: jsx/main.jsx &quot;use strict&quot;; var manager = require('./manager.jsx'); var uimanager = require('./manager-ui.jsx'); var config = require('./config.jsx'); /** * Linkbots API interface. * @namespace Linkbots */ window.Linkbots = (function(){ var mod = {}; var startOpen = false; /** * Adds a Robot to the robot manager. * @function addRobot * @memberOf Linkbots * @param id {string} The robot id to add. */ mod.addRobot = function(id) { manager.addRobot(id); }; /** * @function removeRobot * @memberOf Linkbots * @desc Removes a Robot from the robot manager. * @param id {string} The robot id to remove. */ mod.removeRobot = function(id) { manager.removeRobot(id); }; /** * Opens the robot manager side menu. * @function openSideMenu * @memberOf Linkbots */ mod.openSideMenu = function() { uimanager.uiEvents.trigger('show-menu'); }; /** * Closes the robot manager side menu. * @function closeSideMenu * @memberOf Linkbots */ mod.closeSideMenu = function() { uimanager.uiEvents.trigger('hide-menu'); }; /** * @typedef AcquiredType * @type Object * @property {Array.&lt;AsyncLinkbot&gt;} robots An array of robots. * @property {number} registered The total number of registered robots. * @property {number} ready The total number of robots in the ready state. */ /** * Acquires available robots from the robot manager and marks them as acquired. * @function acquire * @memberOf Linkbots * @param count {int} The number of robots you wish to acquire. * @return {AcquiredType} */ mod.acquire = function(count) { return manager.acquire(count); }; /** * Relinquishes the robot back to the robot manager. It's the opposite of acquire. * @function relinquish * @memberOf Linkbots * @param {AsyncLinkbot} bot The linkbot that you no longer are using and wish to make available. */ mod.relinquish = function(bot) { return manager.relinquish(bot); }; /** * Scans for linkbots. * @function scan * @memberOf Linkbots */ mod.scan = function() { return baroboBridge.scan(); }; /** * If True is passed in the robot manager menu starts open. * @function startOpen * @memberOf Linkbots * @param value {boolean}. */ mod.startOpen = function(value) { startOpen = value; }; /** * Sets the title in the top navigation. * @function setNavigationTitle * @memberOf Linkbots * @param title {string} The title to set. */ mod.setNavigationTitle = function(title) { manager.setNavigationTitle(title); }; /** * Adds a breadcrumb to the top navigation. * @function addNavigationItem * @memberOf Linkbots * @param navItemObject {object} An object containing a url and a title. */ mod.addNavigationItem = function(navItemObject) { manager.addNavigationItem(navItemObject); }; /** * Sets the breadcrumbs to the array of navigation items. Replacing the existing breadcrumbs. * @function setNavigationItems * @memberOf Linkbots * @param navItemArray {array} An array of navigation objects. A navigation object contains a url and title. */ mod.setNavigationItems = function(navItemArray) { manager.setNavigationItems(navItemArray); }; /** * Adds an array of breadcrumbs to the top navigation. * @function addNavigationItems * @memberOf Linkbots * @param navItemArray {array} An array of navigation objects. A navigation object contains a url and title. */ mod.addNavigationItems = function(navItemArray) { manager.addNavigationItems(navItemArray); }; mod.setPathways = function(pathways) { if (!Array.isArray(pathways)) { pathways = [pathways]; } if (!config.set('pathways', pathways)) { uimanager.uiEvents.trigger('add-error', 'Unable to write pathways to the configuration file'); } }; mod.getPathways = function() { var pathways = config.get('pathways'); if (typeof pathways === 'undefined') { return []; } return pathways; }; /** * TODO: document manager events. */ mod.managerEvents = manager.event; /** * TODO document ui events. * @type {*|uiEvents|l} */ mod.uiEvents = uimanager.uiEvents; if(window.attachEvent) { window.attachEvent('onload', function() { uimanager.addUI(); if (startOpen) { uimanager.uiEvents.trigger('show-menu'); } }); } else { if(window.onload) { var originalOnLoad = window.onload; window.onload = function() { originalOnLoad(); uimanager.addUI(); if (startOpen) { uimanager.uiEvents.trigger('show-menu'); } }; } else { window.onload = function() { uimanager.addUI(); if (startOpen) { uimanager.uiEvents.trigger('show-menu'); } } } } return mod; })(); Ã— Search results Close "},"jsx_linkbot.jsx.html":{"id":"jsx_linkbot.jsx.html","title":"Source: jsx/linkbot.jsx","body":" DocStrap Namespaces Linkbots Classes AsyncLinkbot Global asyncBaroboBridge Source: jsx/linkbot.jsx &quot;use strict&quot;; var eventlib = require('./event.jsx'); var manager = require('./manager.jsx'); var firmware = require('./firmware.jsx'); var Version = require('./version.jsx'); var enumConstants = asyncBaroboBridge.enumerationConstants(); var requestId = 0; var callbacks = {}; var buttonEventCallbacks = {}; var encoderEventCallbacks = {}; var accelerometerEventCallbacks = {}; var jointEventCallbacks = {}; function addCallback (func) { var token = requestId++; callbacks[token] = func; return token; } function addGenericCallback () { return addCallback(function (error) { if (error.code !== 0) { // TODO add error handling code here. window.console.warn('error occurred [' + error.category + '] :: ' + error.message); } }); } module.exports.addCallback = addCallback; module.exports.addGenericCallback = addGenericCallback; asyncBaroboBridge.requestComplete.connect( function (token, error, result) { if (callbacks[token]) { callbacks[token](error, result); delete callbacks[token]; } } ); // Dongle events of the same value may occur consecutively (i.e., two // dongleDowns in a row), so track the state and only perform actions on state // changes. var dongleEventFilter = (function () { var lastStatus = null; return function (status, data) { if (!lastStatus || lastStatus !== status) { lastStatus = status; manager.event.trigger(status, data); } }; })(); // This function might be better inside the AsyncLinkbot object? Unsure. function showRobotUpdateButton (explanation, bot) { bot.status = &quot;update&quot;; bot.event.trigger('changed'); window.console.log(explanation); } // True if the error object e represents a particular error, given the error's // category and code in string form. function errorEq(e, category, code) { return e.category === category &amp;&amp; e.code === enumConstants.ErrorCategories[category][code]; } asyncBaroboBridge.dongleEvent.connect( function (error, firmwareVersion) { if (error.code == 0) { var version = Version.fromTriplet(firmwareVersion); if (version.eq(firmware.latestVersion())) { window.console.log('Dongle firmware version ', firmwareVersion); dongleEventFilter('dongleUp'); } else { dongleEventFilter('dongleUpdate', &quot;The dongle's firmware must be updated.&quot;); } } else { if (errorEq(error, 'baromesh', 'STRANGE_DONGLE')) { dongleEventFilter('dongleUpdate', &quot;A dongle is plugged in, but we are unable &quot; + &quot;to communicate with it. &quot; + &quot;You may need to update its firmware.&quot;); } else if (errorEq(error, 'baromesh', 'INCOMPATIBLE_FIRMWARE')) { dongleEventFilter('dongleUpdate', &quot;The dongle's firmware must be updated.&quot;); } else { dongleEventFilter('dongleDown'); window.console.warn('error occurred [' + error.category + '] :: ' + error.message); } } } ); asyncBaroboBridge.robotEvent.connect( function(error, id, firmwareVersion) { console.log('robot event triggered with ID: ' + id + ' and version: ', firmwareVersion); var robot = manager.getRobot(id); if (robot) { if (error.code == 0) { var version = Version.fromTriplet(firmwareVersion); robot.version = version; if (version.eq(firmware.latestVersion())) { robot.connect(); } else { showRobotUpdateButton(id + &quot;'s firmware must be updated.&quot;, robot); } } else if (errorEq(error, 'baromesh', 'INCOMPATIBLE_FIRMWARE')) { showRobotUpdateButton(id + &quot;'s firmware must be updated.&quot;, robot); } else { window.console.warn('error occurred [' + error.category + '] :: ' + error.message); } } } ); asyncBaroboBridge.buttonEvent.connect( function(id, buttonNumber, eventType, timestamp) { // TODO implement this. if (buttonEventCallbacks.hasOwnProperty(id)) { var objs = buttonEventCallbacks[id]; for (var i = 0; i &lt; objs.length; i++) { var obj = objs[i]; if (obj.buttonId == buttonNumber &amp;&amp; eventType == 1) { obj.callback(obj.robot, obj.data, {button: buttonNumber, timestamp: timestamp}); } } } } ); asyncBaroboBridge.encoderEvent.connect( function(id, jointNumber, anglePosition, timestamp) { if (encoderEventCallbacks.hasOwnProperty(id)) { var objs = encoderEventCallbacks[id]; for (var i = 0; i &lt; objs.length; i++) { var obj = objs[i]; if (obj.wheelId == jointNumber) { var diff = anglePosition - obj.robot._wheelPositions[jointNumber-1]; obj.robot._wheelPositions[jointNumber-1] = anglePosition; obj.callback(obj.robot, obj.data, {triggerWheel: jointNumber, position: anglePosition, difference:diff, timestamp: timestamp}); } } } } ); asyncBaroboBridge.jointEvent.connect( function(id, jointNumber, eventType, timestamp) { var objs = jointEventCallbacks[id]; for (var i = 0; i &lt; objs.length; i++) { var obj = objs[i]; obj.callback(obj.robot, obj.data, {jointNumber: jointNumber, eventType: eventType, timestamp: timestamp}); } } ); asyncBaroboBridge.accelerometerEvent.connect( function(id, x, y, z, timestamp) { if (accelerometerEventCallbacks.hasOwnProperty(id)) { var objs = accelerometerEventCallbacks[id]; for (var i = 0; i &lt; objs.length; i++) { var obj = objs[i]; obj.callback(obj.robot, obj.data, {x: x, y: y, z: z, timestamp: timestamp}); } } } ); asyncBaroboBridge.acquire.connect( function() { var acquisition = manager.acquire(1); var id = acquisition.robots.length &gt; 0 ? acquisition.robots[0].id : &quot;&quot;; asyncBaroboBridge.fulfillAcquire(id); } ); asyncBaroboBridge.relinquish.connect( function(id) { manager.relinquish(manager.getRobot(id)); } ); function rgbToHex(value) { if (!value || value === null || value === &quot;undefined&quot;) { return &quot;00&quot;; } var val = Math.round(value); val = val.toString(16); if (val.length &lt; 2) { val = &quot;0&quot; + val; } return val; } function sign(value) { return (value &gt; 0) - (value &lt; 0); } function colorToHex(color) { var red = rgbToHex(color.red); var green = rgbToHex(color.green); var blue = rgbToHex(color.blue); return red + green + blue; } module.exports.startFirmwareUpdate = function() { firmware.startUpdater(); }; /** * Linkbot. * @class AsyncLinkbot * @param _id {string} The id of the linkbot. * @constructor * @property _wheelRadius {number} The wheel radius. * @property status {string} The status of the linkbot. * @property version {string} The firmware version. * @property id {string} The robot id. */ module.exports.AsyncLinkbot = function AsyncLinkbot(_id) { var bot = this; var statuses = {0:&quot;offline&quot;, 1:&quot;ready&quot;, 2:&quot;acquired&quot;, 3:&quot;update&quot;}; var status = 0; var id = _id; var wheelRadius = 1.75; var joinDirection = [0, 0, 0]; var driveToValue = null; var driveToCalled = false; var version = null; /** * Enumeration constants. * @type {{Button, ButtonState, FormFactor, JointState}} */ bot.enums = enumConstants; function driveToCallback(error) { driveToCalled = false; if (error.code !== 0) { // TODO add error handling code here. window.console.warn('error occurred [' + error.category + '] :: ' + error.message); } else { if (driveToValue !== null) { bot.driveTo(driveToValue[0], driveToValue[1], driveToValue[2]); driveToValue = null; } } } function checkVersions(error, data) { if (0 === error.code) { var version = Version.fromTriplet(data); var robot = manager.getRobot(id); robot.version = version; window.console.log('checking version: ' + version); if (version.eq(firmware.latestVersion())) { window.console.log('Using firmware version: ' + version + ' for bot: ' + id); } else { showRobotUpdateButton(id + &quot;'s firmware must be updated.&quot;, robot); } } else { window.console.warn('error occurred checking firmware version [' + error.category + '] :: ' + error.message); } } bot._wheelPositions = [0, 0, 0]; // Public bot.__defineGetter__(&quot;_wheelRadius&quot;, function(){ return wheelRadius; }); bot.__defineSetter__(&quot;_wheelRadius&quot;, function(value){ wheelRadius = value; bot.event.trigger('changed'); }); bot.__defineGetter__(&quot;status&quot;, function(){ return statuses[status]; }); bot.__defineSetter__(&quot;version&quot;, function(value) { version = value; }); bot.__defineGetter__(&quot;version&quot;, function() { return version; }); bot.__defineSetter__(&quot;status&quot;, function(val) { if (val === &quot;ready&quot;) { status = 1; } else if (val === &quot;offline&quot;) { status = 0; } else if (val === &quot;acquired&quot;) { status = 2; } else if (val === &quot;update&quot;) { status = 3; } bot.event.trigger('changed'); }); bot.__defineGetter__(&quot;id&quot;, function() { return id; }); // For Backwards compatibility. bot.__defineGetter__(&quot;_id&quot;, function() { return id; }); /** * Color value. * @typedef ColorType * @property {number} red Value between 0 to 255 representing the red color value. * @property {number} green Value between 0 to 255 representing the red color value. * @property {number} blue Value between 0 to 255 representing the red color value. */ /** * Color Callback. * * @callback robotColorCallback * @param {ColorType} color The color values. */ /** * Returns the robot LED color in a callback. * @function getColor * @memberOf AsyncLinkbot * @param {robotColorCallback} callback The color callback. * @instance */ bot.getColor = function(callback) { asyncBaroboBridge.getLedColor(id, addCallback(function(error, data) { if (0 == error.code) { callback(data); } else { callback({red:96,green:96,blue:96}); } })); }; /** * Hex Color Callback. * @callback robotHexColorCallback * @param {string} hexColor A hex string representing the LED color value. */ /** * Returns the robot LED color in a callback. * @function getHexColor * @memberOf AsyncLinkbot * @param {robotHexColorCallback} callback The color callback. * @instance */ bot.getHexColor = function(callback) { asyncBaroboBridge.getLedColor(id, addCallback(function(error, data) { if (0 == error.code) { callback(colorToHex(data)); } else { callback('606060'); } })); }; /** * Sets the robots LED value. * @function color * @memberOf AsyncLinkbot * @param r {number} The red value between 0 and 255. * @param g {number} The green value between 0 and 255. * @param b {number} The blue value between 0 and 255. * @instance */ bot.color = function(r, g, b) { if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.setLedColor(id, token, r, g, b); bot.event.trigger('changed'); } }; /** * Sets the motor angular speed. * @function angularSpeed * @memberOf AsyncLinkbot * @param s1 {number} The angular speed value for motor 1. * @param s2 {number} The angular speed value for motor 2. * @param s3 {number} The angular speed value for motor 3. * @instance */ bot.angularSpeed = function(s1, s2, s3) { if (s2 === null) { s2 = s1; } if (s3 === null) { s3 = s1; } if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.setJointSpeeds(id, token, 7, s1, s2, s3); } }; /** * Runs the motors the specified number of degrees. Positive values move * the wheel clockwise. * @function move * @memberOf AsyncLinkbot * @param r1 {number} value to move motor 1 to. * @param r2 {number} value to move motor 2 to. * @param r3 {number} value to move motor 3 to. * @instance */ bot.move = function(r1, r2, r3) { if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.move(id, token, 7, r1, r2, r3); } }; /** * Moves the motors to a particular absolute position. The Linkbot has an * internal sense of zero that it uses for this method. * @function moveTo * @memberOf AsyncLinkbot * @param r1 {number} value to move motor 1 to. * @param r2 {number} value to move motor 2 to. * @param r3 {number} value to move motor 3 to. * @instance */ bot.moveTo = function(r1, r2, r3) { if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.moveTo(id, token, 7, r1, r2, r3); } }; /** * Moves a single motor to a particular absolute position. * @function moveToOneMotor * @see AsyncLinkbot.moveTo * @memberOf AsyncLinkbot * @param joint {number} The motor joint to move (0, 1, or 2). * @param position {number} The position to move the motor to. * @instance */ bot.moveToOneMotor = function(joint, position) { if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); var mask = 0; if (joint === 0) { mask = 1; } else if (joint === 1) { mask = 2; } else if (joint === 2) { mask = 4; } asyncBaroboBridge.moveTo(id, token, mask, position, position, position); } }; /** * Drives the motors the specified number of degrees. Positive values move * the wheel clockwise. * @function drive * @memberOf AsyncLinkbot * @param r1 {number} value to drive motor 1 to. * @param r2 {number} value to drive motor 2 to. * @param r3 {number} value to drive motor 3 to. * @instance */ bot.drive = function(r1, r2, r3) { if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.drive(id, token, 7, r1, r2, r3); } }; /** * Drives the motors to a particular absolute position. The Linkbot has an * internal sense of zero that it uses for this method. * @function driveTo * @memberOf AsyncLinkbot * @param r1 {number} value to drive motor 1 to. * @param r2 {number} value to drive motor 2 to. * @param r3 {number} value to drive motor 3 to. * @instance */ bot.driveTo = function(r1, r2, r3) { if (status != 0 &amp;&amp; status != 3) { if (driveToCalled) { driveToValue = [r1, r2, r3]; } else { driveToCalled = true; var token = addCallback(driveToCallback); asyncBaroboBridge.driveTo(id, token, 7, r1, r2, r3); } } }; /** * Moves an I-Linkbot in the forward direction. * @function moveForward * @memberOf AsyncLinkbot * @instance */ bot.moveForward = function() { joinDirection[0] = 1; joinDirection[2] = -1; if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.moveContinuous(id, token, 7, joinDirection[0], joinDirection[1], joinDirection[2]); } }; /** * Moves an I-Linkbot in the backwards direction. * @function moveBackward * @memberOf AsyncLinkbot * @instance */ bot.moveBackward = function() { joinDirection[0] = -1; joinDirection[2] = 1; if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.moveContinuous(id, token, 7, joinDirection[0], joinDirection[1], joinDirection[2]); } }; /** * Moves an I-Linkbot to the left. * @function moveBackward * @memberOf AsyncLinkbot * @instance */ bot.moveLeft = function() { joinDirection[0] = -1; joinDirection[2] = -1; if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.moveContinuous(id, token, 7, joinDirection[0], joinDirection[1], joinDirection[2]); } }; /** * Moves an I-Linkbot to the right. * @function moveBackward * @memberOf AsyncLinkbot * @instance */ bot.moveRight = function() { joinDirection[0] = 1; joinDirection[2] = 1; if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.moveContinuous(id, token, 7, joinDirection[0], joinDirection[1], joinDirection[2]); } }; /** * Moves a Joint continuously in a specific direction. * @function moveJointContinuous * @memberOf AsyncLinkbot * @param joint {number} The robot motor number to move. * @param direction {number} (1,0, or -1) Positive numbers move the robot motor in the positive direction, zero stops and -1 moves the motor in the negative direction. * @return {boolean} True if the input was valid and sent to the robot. * @instance */ bot.moveJointContinuous = function(joint, direction) { var token, mask = 0; if (joint &gt;= 0 &amp;&amp; joint &lt;= 2) { if (direction &gt; 0) { joinDirection[joint] = 1; } else if (direction &lt; 0) { joinDirection[joint] = -1; } else { joinDirection[joint] = 0; // Special call for stopping so it relaxes the motor. token = addGenericCallback(); asyncBaroboBridge.stop(id, token, (1 &lt;&lt; joint)); return true; } if (status != 0 &amp;&amp; status != 3) { token = addGenericCallback(); if (joint === 0) { mask = 1; } else if (joint === 1) { mask = 2; } else if (joint === 2) { mask = 4; } asyncBaroboBridge.moveContinuous(id, token, mask, joinDirection[0], joinDirection[1], joinDirection[2]); } return true; } return false; }; /** * Wheel Positions type. * @typedef WheelPositionsType * @property {Array.number} values An array containing the wheel positions. * @property {number} timestamp A timestamp of when representing the time the wheels were at that position. * if there was an error the timestamp will be set to -1. */ /** * Wheel Positions Callback. * @callback robotWheelPositionsCallback * @param {WheelPositionsType} color The color values. */ /** * Call to get the wheel positions of the Linkbot. * @function wheelPositions * @memberOf AsyncLinkbot * @param callback {robotWheelPositionsCallback} A callback that returns the wheel positions. * @instance */ bot.wheelPositions = function(callback) { if (status != 0 &amp;&amp; status != 3) { var token = addCallback(function(error, data) { if (error.code == 0) { callback(data); } else { callback({values:[0, 0, 0], timestamp:-1}); } }); asyncBaroboBridge.getJointAngles (id, token); } }; /** * Joint Speeds Callback. * @callback robotJointSpeedsCallback * @param {Array.number} An array of joint speeds. */ /** * Call to get the joint speeds of the Linkbot. * @function getJointSpeeds * @memberOf AsyncLinkbot * @param callback {robotJointSpeedsCallback} The joint speeds returned as a callback. * @instance */ bot.getJointSpeeds = function(callback) { if (status != 0 &amp;&amp; status != 3) { var token = addCallback(function(error, data) { if (error.code == 0) { callback(data); } else { window.console.warn('error occurred [' + error.category + '] :: ' + error.message); } }); asyncBaroboBridge.getJointSpeeds(id, token); } }; /** * Stops all motors on the robot. * @function stop * @memberOf AsyncLinkbot * @instance */ bot.stop = function() { joinDirection[0] = 0; joinDirection[2] = 0; if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.stop(id, token); } }; /** * Sets the buzzer frequency for the robot. This is how you make it make sounds. * @function buzzerFrequency * @memberOf AsyncLinkbot * @param freq {number} The frequency value. * @instance */ bot.buzzerFrequency = function(freq) { if (status != 0 &amp;&amp; status != 3) { var token = addGenericCallback(); asyncBaroboBridge.setBuzzerFrequency(id, token, freq); } }; /** * Moves all the Linkbot motors to the zero position. * @function zero * @memberOf AsyncLinkbot * @instance */ bot.zero = function() { if (asyncBaroboBridge.resetEncoderRevs) { var token = addCallback(function(error) { if (error.code !== 0) { // TODO add error handling code here. window.console.warn('error occurred [' + error.category + '] :: ' + error.message); } else { bot.moveTo(0, 0, 0); } }); asyncBaroboBridge.resetEncoderRevs(id, token); } else { bot.moveTo(0, 0, 0); } }; /** * Form Factor Callback. * ex. * linkbot.getFormFactor(function(data) { * if (linkbot.enums.FormFactor.I == data) { * // The linkbot is an I-Linkbot. * } * }); * @callback robotFormFactorCallback * @param {enum} FormFactor the form factor is returned and should be checked against the enums.FormFactor. */ /** * Returns the Linkbot form factor. * @param callback {robotFormFactorCallback} The form factor as a callback. * @instance */ bot.getFormFactor = function(callback) { if (status != 0 &amp;&amp; status != 3 &amp;&amp; callback) { var token = addCallback(function(error, data) { if (error.code == 0) { callback(data); } else { window.console.warn('error occurred [' + error.category + '] :: ' + error.message); } }); asyncBaroboBridge.getFormFactor(id, token); } }; /** * Disconnects from the Linkbot. It also calls the stop() and unregister methods before disconnecting. * @function disconnect * @memberOf AsyncLinkbot * @return {string} The Linkbot id. * @instance */ bot.disconnect = function() { bot.stop(); bot.unregister(); var token = addGenericCallback(); asyncBaroboBridge.disconnectRobot(id, token); bot.status = &quot;offline&quot;; return id; }; /** * Connects to a Linkbot. * @function connect * @memberOf AsyncLinkbot * @param callback {Object} the callback is called if there was an error. The error object is returned. * @instance */ bot.connect = function(callback) { var token; if (status == 0) { asyncBaroboBridge.connectRobot(id, addCallback(function(error) { if (0 == error.code) { // If a TCP tunnel is currently active for this robot, it starts // acquired. bot.status = asyncBaroboBridge.isTunnelActive(id) ? &quot;acquired&quot; : &quot;ready&quot;; bot.event.trigger('changed'); asyncBaroboBridge.getVersions(id, addCallback(checkVersions)); } else if (errorEq(error, 'rpc', 'DECODING_FAILURE') || errorEq(error, 'rpc', 'PROTOCOL_ERROR') || errorEq(error, 'rpc', 'INTERFACE_ERROR')) { showRobotUpdateButton(&quot;We are unable to communicate with &quot; + id + &quot;. It may need a firmware update.&quot;, bot); } else if (errorEq(error, 'rpc', 'VERSION_MISMATCH')) { showRobotUpdateButton(id + &quot;'s firmware must be updated.&quot;, bot); } else { window.console.warn('error occurred [' + error.category + '] :: ' + error.message); } if (callback) { callback(error); } })); } else { token = addCallback(function(error) { if (0 != error.code) { status = 0; bot.event.trigger('changed'); } else { window.console.warn('error occurred [' + error.category + '] :: ' + error.message); } if (callback) { callback(error); } }); asyncBaroboBridge.getLedColor(id, token); } }; /** * Acceleration connection type. * @typedef AccelConnectionType * @property callback {function} The function to be called back for acceleration events. * function(robot, data, event) - The data is what you set when you registered. The event is an object with x, y, z * values. * @property data {Object} Optional the data you want returned on callback. */ /** * Button connection type. * @typedef ButtonConnectionType * @property {Object} 0 The button number to register for as an object. See enums for button numbers. * ex. * { * 0: { * callback: function(robot, data, event) { ... } * data: ... * } * } */ /** * Wheel connection type. * @typedef WheelConnectionType * @property {Object} 0 The motor number (starts at zero) to register for as an object. * ex. * { * 0: { * callback: function(robot, data, event) { ... } * data: ... * distance: (this is optional and specifies the granularity). * } * } */ /** * Joint connection type. * @typedef JointConnectionType * @property callback {function} The function to be called back for acceleration events. * function(robot, data, event) - The data is what you set when you registered. The event is an object with x, y, z * values. * @property data {Object} Optional the data you want returned on callback. */ /** * @typedef ConnectionsType * @property accel {AccelConnectionType} Optional object that contains accel callback and data. * @property button {ButtonConnectionType} Optional object that contains button callback and data. * @property wheel {WheelConnectionType} Optional object that contains wheel callback and data. * @property joint {JointConnectionType} Option object that contains joint callback and data. */ /** * Registers for Linkbot events. * @function register * @memberOf AsyncLinkbot * @param connections {ConnectionsType} an object containing callbacks and data you want to register for. * @instance */ bot.register = function(connections) { var obj, token; if (status == 0 || status == 3 || typeof(connections) == 'undefined') { return; } if (connections.hasOwnProperty('button')) { buttonEventCallbacks.hasOwnProperty(id) || (buttonEventCallbacks[id] = []); for (var buttonId in connections.button) { if (connections.button.hasOwnProperty(buttonId)) { obj = connections.button[buttonId]; buttonEventCallbacks[id].push({ robot: bot, buttonId: buttonId, callback: obj.callback, data: obj.data }); } } if (buttonEventCallbacks[id].length &gt; 0) { token = addGenericCallback(); asyncBaroboBridge.enableButtonEvents (id, token, true); } } if (connections.hasOwnProperty('wheel')) { var granularity = 5.0; encoderEventCallbacks.hasOwnProperty(id) || (encoderEventCallbacks[id] = []); for (var wheelId in connections.wheel) { if (connections.wheel.hasOwnProperty(wheelId)) { obj = connections.wheel[wheelId]; encoderEventCallbacks[id].push({ robot: bot, wheelId: wheelId, callback: obj.callback, data: obj.data }); if (obj.hasOwnProperty('distance') &amp;&amp; obj.distance &lt; granularity) { granularity = obj.distance; } } } if (encoderEventCallbacks[id].length &gt; 0) { token = addGenericCallback(); asyncBaroboBridge.enableEncoderEvents(id, token, granularity, true); } } if (connections.hasOwnProperty('joint')) { obj = connections.joint; jointEventCallbacks.hasOwnProperty(id) || (jointEventCallbacks[id] = []); jointEventCallbacks[id].push({robot:bot, callback:obj.callback, data:obj.data}); token = addGenericCallback(); asyncBaroboBridge.enableJointEvents(id, token, true); } if (connections.hasOwnProperty('accel')) { obj = connections.accel; accelerometerEventCallbacks.hasOwnProperty(id) || (accelerometerEventCallbacks[id] = []); accelerometerEventCallbacks[id].push({robot:bot, callback:obj.callback, data:obj.data}); token = addGenericCallback(); asyncBaroboBridge.enableAccelerometerEvents(id, token, true); } }; /** * Unregisters from Linkbot events. * @function unregister * @memberOf AsyncLinkbot * @instance */ bot.unregister = function() { var token; if (buttonEventCallbacks.hasOwnProperty(id) &amp;&amp; buttonEventCallbacks[id].length &gt; 0) { token = addGenericCallback(); asyncBaroboBridge.enableButtonEvents (id, token, false); } if (encoderEventCallbacks.hasOwnProperty(id) &amp;&amp; encoderEventCallbacks[id].length &gt; 0) { token = addGenericCallback(); asyncBaroboBridge.enableEncoderEvents(id, token, 5.0, false); } if (accelerometerEventCallbacks.hasOwnProperty(id) &amp;&amp; accelerometerEventCallbacks[id].length &gt; 0) { token = addGenericCallback(); asyncBaroboBridge.enableAccelerometerEvents(id, token, false); } if (jointEventCallbacks.hasOwnProperty(id) &amp;&amp; jointEventCallbacks[id].length &gt; 0) { token = addGenericCallback(); asyncBaroboBridge.enableJointEvents(id, token, false); } }; bot.event = eventlib.Events.extend({}); /** * Deprecated Button Constants. * Used when registering button callbacks. */ bot.BUTTON_POWER = bot.enums.Button.POWER; bot.BUTTON_A = bot.enums.Button.A; bot.BUTTON_B = bot.enums.Button.B; }; Ã— Search results Close "},"js_barobo-bridge.js.html":{"id":"js_barobo-bridge.js.html","title":"Source: js/barobo-bridge.js","body":" DocStrap Namespaces Linkbots Classes AsyncLinkbot Global asyncBaroboBridge Source: js/barobo-bridge.js /** * This class exists for testing outside of Barobo browser. */ var asyncBaroboBridge = (function(main) { &quot;use strict&quot;; if (main.asyncBaroboBridge &amp;&amp; main.asyncBaroboBridge !== null) { return main.asyncBaroboBridge; } else { var _i, _j, _len, _len1, obj, signals, methods, k; methods = ['listFirmwareFiles', 'connectRobot', 'disconnectRobot', 'getAccelerometer', 'getFormFactor', 'getJointAngles', 'getJointSpeeds', 'getJointStates', 'getLedColor', 'getVersions', 'resetEncoderRevs', 'setBuzzerFrequency', 'setJointSpeeds', 'setJointStates', 'setLedColor', 'move', 'moveContinuous', 'moveTo', 'drive', 'driveTo', 'motorPower', 'stop', 'enableButtonEvents', 'enableEncoderEvents', 'enableJointEvents', 'enableAccelerometerEvents', 'firmwareUpdate', 'sendRobotPing']; signals = ['requestComplete', 'dongleEvent', 'acquire', 'relinquish', 'buttonEvent', 'encoderEvent', 'jointEvent', 'accelerometerEvent', 'robotEvent', 'connectionTerminated']; obj = { mock: true }; /* var randomInt = function(min,max) { return Math.floor(Math.random()*(max-min+1)+min); }; var colorMap = {}; */ var emptyFunction = function() { }; for (_i = 0, _len = methods.length; _i &lt; _len; _i++) { k = methods[_i]; obj[k] = emptyFunction; } for (_j = 0, _len1 = signals.length; _j &lt; _len1; _j++) { k = signals[_j]; obj[k] = { connect: emptyFunction, disconnect: emptyFunction }; } obj.enumerationConstants = function() { return { Button: { A: 1, B: 2, POWER: 0}, ButtonState: { DOWN:1, UP: 0}, FormFactor: {I:0, L: 1, T: 2}, JointState: {FAIL: 3, HOLD: 1, MOVING: 2, STOP: 0} }; }; obj.listFirmwareFiles = function() { return [&quot;v4.4.6.eeprom&quot;, &quot;v4.4.6.hex&quot;]; }; obj.configuration = {}; /* obj.getLEDColor = function(id) { if (!colorMap[id]) { colorMap[id] = {red:randomInt(0,255), green:randomInt(0,255), blue:randomInt(0,255)}; } return colorMap[id]; }; obj.setLEDColor = function(id, r, g, b) { colorMap[id] = {red:r, green:g, blue:b}; }; */ return obj; } })(this); Ã— Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Namespaces Linkbots Classes AsyncLinkbot Global asyncBaroboBridge Global Members asyncBaroboBridge This class exists for testing outside of Barobo browser. Source: js/barobo-bridge.js, line 4 Type Definitions AccelConnectionType Acceleration connection type. Properties: Name Type Description callback function The function to be called back for acceleration events.function(robot, data, event) - The data is what you set when you registered. The event is an object with x, y, zvalues. data Object Optional the data you want returned on callback. Source: jsx/linkbot.jsx, line 792 AcquiredType Type: Object Properties: Name Type Description robots Array.&lt;AsyncLinkbot&gt; An array of robots. registered number The total number of registered robots. ready number The total number of robots in the ready state. Source: jsx/main.jsx, line 50 ButtonConnectionType Button connection type. Properties: Name Type Description 0 Object The button number to register for as an object. See enums for button numbers.ex.{ 0: { callback: function(robot, data, event) { ... } data: ... }} Source: jsx/linkbot.jsx, line 801 ColorType Color value. Properties: Name Type Description red number Value between 0 to 255 representing the red color value. green number Value between 0 to 255 representing the red color value. blue number Value between 0 to 255 representing the red color value. Source: jsx/linkbot.jsx, line 306 ConnectionsType Properties: Name Type Description accel AccelConnectionType Optional object that contains accel callback and data. button ButtonConnectionType Optional object that contains button callback and data. wheel WheelConnectionType Optional object that contains wheel callback and data. joint JointConnectionType Option object that contains joint callback and data. Source: jsx/linkbot.jsx, line 837 JointConnectionType Joint connection type. Properties: Name Type Description callback function The function to be called back for acceleration events.function(robot, data, event) - The data is what you set when you registered. The event is an object with x, y, zvalues. data Object Optional the data you want returned on callback. Source: jsx/linkbot.jsx, line 828 robotColorCallback(color) Color Callback. Parameters: Name Type Description color ColorType The color values. Source: jsx/linkbot.jsx, line 314 robotFormFactorCallback(FormFactor) Form Factor Callback.ex.linkbot.getFormFactor(function(data) { if (linkbot.enums.FormFactor.I == data) { // The linkbot is an I-Linkbot. }}); Parameters: Name Type Description FormFactor enum the form factor is returned and should be checked against the enums.FormFactor. Source: jsx/linkbot.jsx, line 694 robotHexColorCallback(hexColor) Hex Color Callback. Parameters: Name Type Description hexColor string A hex string representing the LED color value. Source: jsx/linkbot.jsx, line 337 robotJointSpeedsCallback(An) Joint Speeds Callback. Parameters: Name Type Description An Array.number array of joint speeds. Source: jsx/linkbot.jsx, line 617 robotWheelPositionsCallback(color) Wheel Positions Callback. Parameters: Name Type Description color WheelPositionsType The color values. Source: jsx/linkbot.jsx, line 591 WheelConnectionType Wheel connection type. Properties: Name Type Description 0 Object The motor number (starts at zero) to register for as an object.ex.{ 0: { callback: function(robot, data, event) { ... } data: ... distance: (this is optional and specifies the granularity). }} Source: jsx/linkbot.jsx, line 814 WheelPositionsType Wheel Positions type. Properties: Name Type Description values Array.number An array containing the wheel positions. timestamp number A timestamp of when representing the time the wheels were at that position.if there was an error the timestamp will be set to -1. Source: jsx/linkbot.jsx, line 583 Ã— Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Namespaces Linkbots Classes AsyncLinkbot Global asyncBaroboBridge Classes Classes AsyncLinkbot Namespaces Linkbots Ã— Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" DocStrap Namespaces Linkbots Classes AsyncLinkbot Global asyncBaroboBridge Namespaces Classes AsyncLinkbot Namespaces Linkbots Ã— Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Namespaces Linkbots Classes AsyncLinkbot Global asyncBaroboBridge LinkbotJS APIThis is the user documentation for LinkbotJS. It describes version 0.0.3,which is available here: linkbot.js.zip v0.0.3 Source code and contributor documentation is available on Github atBaroboRobotics/LinkbotJS. This API has two methods for managing robots and aLinkbot classfor controlling individual robots. The two management methods arescan andconnect. Linkbots Object Methodsscan returns a list of ids. var availIds = Linkbots.scan();connect is straightforward, though it might throw an error if theconnection fails. As mentioned above, it returns a Linkbot object. var bot; try { bot = Linkbots.connect(id); } catch(/* TODO */) { } Linkbot ClassTo get started, obtain a Linkbot object withconnect: var bot = Linkbots.connect(id);Linkbot objects have the following methods:color,angularSpeed,move,moveTo,stop,wheelPositions,disconnect,register, andunregister. Controlling the Linkbotcolor sets the robot's LED. Inputs are r, g, b, with values0-255. bot.color(255, 0, 0); // Set LED to red.angularSpeedsets wheel speeds, in degrees per second. This is treated as a magnitude.Only use positive values. Argument 1 corresponds to wheel 1, etc. bot.angularSpeed(10, 20, 10); /* bad: negative numbers */ /* bot.angularSpeed(-10, 10, 20) */If you only pass one argument, LinkbotJS will use that speed for all thewheels. /* same as bot.angularSpeed(10,10,10) */ bot.angularSpeed(10);moveruns the wheels the specified number of degrees. The speed they move at iscontrolled by angularSpeed. Positive values movethe wheel clockwise. bot.move(10, 0, -10);moveTomoves the wheels to a particular absolute position. The Linkbot has aninternal sense of zero that it uses for this method. stopis an emergency stop! bot.stop();wheelPositionsreturns an array of absolute wheel positions. disconnectrelinquishes control of the robot. It also invalidates the object it isexecuted on. Let me know if that's weird. bot.disconnect();Linkbot EventsLinkbots can communicate with your code through event callbacks. Callbacks canberegisteredandunregistered, and will be invoked in a standardway: /* Callback invocation */ callback(robot, userData, event)TODO: explain the parameters once the design settles down. The available event types are listed below. registerIn lieu of complete documentation, here is an example of registering threecallbacks: bot.register({ wheel: { /* When wheel 1 moves 20 degrees, run doStuff. Pass myData as 2nd argument to doStuff. */ 1: { distance: 20, callback: doStuff, data: myData }, /* Run doOtherThings whenever wheel 2 moves at all. */ 2: { callback: doOtherThings } }, button: { /* Run fireZeMissiles when button 3 is pressed. */ 3: { callback: fireZeMissiles } } }) unregisterfixme: unimplemented Event typesThe available events are: buttonThe event object (the third argument to the callback) has form { buttonId(int) }wheelThe event object has form { triggerWheel(int), / which wheel triggered the event? / timestamp(int), / when did the Linkbot fire the event? / positions([int]) / wheel positions when the event fired / } Including the API in your codeEventual support of require.js is planned, but for now, include linkbot.jsbefore your application code, and Linkbots will be available at theglobal scope. Ã— Search results Close "},"AsyncLinkbot.html":{"id":"AsyncLinkbot.html","title":"Class: AsyncLinkbot","body":" DocStrap Namespaces Linkbots Classes AsyncLinkbot Global asyncBaroboBridge Class: AsyncLinkbot AsyncLinkbot AsyncLinkbot new AsyncLinkbot(_id) Linkbot. Parameters: Name Type Description _id string The id of the linkbot. Properties: Name Type Description _wheelRadius number The wheel radius. status string The status of the linkbot. version string The firmware version. id string The robot id. Source: jsx/linkbot.jsx, line 223 Methods angularSpeed(s1, s2, s3) Sets the motor angular speed. Parameters: Name Type Description s1 number The angular speed value for motor 1. s2 number The angular speed value for motor 2. s3 number The angular speed value for motor 3. Source: jsx/linkbot.jsx, line 376 buzzerFrequency(freq) Sets the buzzer frequency for the robot. This is how you make it make sounds. Parameters: Name Type Description freq number The frequency value. Source: jsx/linkbot.jsx, line 658 color(r, g, b) Sets the robots LED value. Parameters: Name Type Description r number The red value between 0 and 255. g number The green value between 0 and 255. b number The blue value between 0 and 255. Source: jsx/linkbot.jsx, line 360 connect(callback) Connects to a Linkbot. Parameters: Name Type Description callback Object the callback is called if there was an error. The error object is returned. Source: jsx/linkbot.jsx, line 742 disconnect() Disconnects from the Linkbot. It also calls the stop() and unregister methods before disconnecting. Source: jsx/linkbot.jsx, line 724 Returns: The Linkbot id. Type string drive(r1, r2, r3) Drives the motors the specified number of degrees. Positive values movethe wheel clockwise. Parameters: Name Type Description r1 number value to drive motor 1 to. r2 number value to drive motor 2 to. r3 number value to drive motor 3 to. Source: jsx/linkbot.jsx, line 452 driveTo(r1, r2, r3) Drives the motors to a particular absolute position. The Linkbot has aninternal sense of zero that it uses for this method. Parameters: Name Type Description r1 number value to drive motor 1 to. r2 number value to drive motor 2 to. r3 number value to drive motor 3 to. Source: jsx/linkbot.jsx, line 468 getColor(callback) Returns the robot LED color in a callback. Parameters: Name Type Description callback robotColorCallback The color callback. Source: jsx/linkbot.jsx, line 321 getHexColor(callback) Returns the robot LED color in a callback. Parameters: Name Type Description callback robotHexColorCallback The color callback. Source: jsx/linkbot.jsx, line 343 getJointSpeeds(callback) Call to get the joint speeds of the Linkbot. Parameters: Name Type Description callback robotJointSpeedsCallback The joint speeds returned as a callback. Source: jsx/linkbot.jsx, line 623 move(r1, r2, r3) Runs the motors the specified number of degrees. Positive values movethe wheel clockwise. Parameters: Name Type Description r1 number value to move motor 1 to. r2 number value to move motor 2 to. r3 number value to move motor 3 to. Source: jsx/linkbot.jsx, line 397 moveBackward() Moves an I-Linkbot in the backwards direction. Source: jsx/linkbot.jsx, line 503 moveBackward() Moves an I-Linkbot to the right. Source: jsx/linkbot.jsx, line 531 moveBackward() Moves an I-Linkbot to the left. Source: jsx/linkbot.jsx, line 517 moveForward() Moves an I-Linkbot in the forward direction. Source: jsx/linkbot.jsx, line 489 moveJointContinuous(joint, direction) Moves a Joint continuously in a specific direction. Parameters: Name Type Description joint number The robot motor number to move. direction number (1,0, or -1) Positive numbers move the robot motor in the positive direction, zero stops and -1 moves the motor in the negative direction. Source: jsx/linkbot.jsx, line 545 Returns: True if the input was valid and sent to the robot. Type boolean moveTo(r1, r2, r3) Moves the motors to a particular absolute position. The Linkbot has aninternal sense of zero that it uses for this method. Parameters: Name Type Description r1 number value to move motor 1 to. r2 number value to move motor 2 to. r3 number value to move motor 3 to. Source: jsx/linkbot.jsx, line 413 moveToOneMotor(joint, position) Moves a single motor to a particular absolute position. Parameters: Name Type Description joint number The motor joint to move (0, 1, or 2). position number The position to move the motor to. Source: jsx/linkbot.jsx, line 429 See: AsyncLinkbot.moveTo register(connections) Registers for Linkbot events. Parameters: Name Type Description connections ConnectionsType an object containing callbacks and data you want to register for. Source: jsx/linkbot.jsx, line 845 stop() Stops all motors on the robot. Source: jsx/linkbot.jsx, line 643 unregister() Unregisters from Linkbot events. Source: jsx/linkbot.jsx, line 912 wheelPositions(callback) Call to get the wheel positions of the Linkbot. Parameters: Name Type Description callback robotWheelPositionsCallback A callback that returns the wheel positions. Source: jsx/linkbot.jsx, line 597 zero() Moves all the Linkbot motors to the zero position. Source: jsx/linkbot.jsx, line 672 Ã— Search results Close "},"Linkbots.html":{"id":"Linkbots.html","title":"Namespace: Linkbots","body":" DocStrap Namespaces Linkbots Classes AsyncLinkbot Global asyncBaroboBridge Namespace: Linkbots Linkbots Linkbots API interface. Source: jsx/main.jsx, line 6 Methods &lt;static&gt; acquire(count) Acquires available robots from the robot manager and marks them as acquired. Parameters: Name Type Description count int The number of robots you wish to acquire. Source: jsx/main.jsx, line 58 Returns: Type AcquiredType &lt;static&gt; addNavigationItem(navItemObject) Adds a breadcrumb to the top navigation. Parameters: Name Type Description navItemObject object An object containing a url and a title. Source: jsx/main.jsx, line 103 &lt;static&gt; addNavigationItems(navItemArray) Adds an array of breadcrumbs to the top navigation. Parameters: Name Type Description navItemArray array An array of navigation objects. A navigation object contains a url and title. Source: jsx/main.jsx, line 121 &lt;static&gt; addRobot(id) Adds a Robot to the robot manager. Parameters: Name Type Description id string The robot id to add. Source: jsx/main.jsx, line 14 &lt;static&gt; closeSideMenu() Closes the robot manager side menu. Source: jsx/main.jsx, line 41 &lt;static&gt; openSideMenu() Opens the robot manager side menu. Source: jsx/main.jsx, line 33 &lt;static&gt; relinquish(bot) Relinquishes the robot back to the robot manager. It's the opposite of acquire. Parameters: Name Type Description bot AsyncLinkbot The linkbot that you no longer are using and wish to make available. Source: jsx/main.jsx, line 68 &lt;static&gt; removeRobot(id) Removes a Robot from the robot manager. Parameters: Name Type Description id string The robot id to remove. Source: jsx/main.jsx, line 24 &lt;static&gt; scan() Scans for linkbots. Source: jsx/main.jsx, line 77 &lt;static&gt; setNavigationItems(navItemArray) Sets the breadcrumbs to the array of navigation items. Replacing the existing breadcrumbs. Parameters: Name Type Description navItemArray array An array of navigation objects. A navigation object contains a url and title. Source: jsx/main.jsx, line 112 &lt;static&gt; setNavigationTitle(title) Sets the title in the top navigation. Parameters: Name Type Description title string The title to set. Source: jsx/main.jsx, line 94 &lt;static&gt; startOpen(value) If True is passed in the robot manager menu starts open. Parameters: Name Type Description value boolean . Source: jsx/main.jsx, line 85 Ã— Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
